% mechanize documentation: forms

<span class="docwarning">This documentation is in need of reorganisation!</span>

This page is the old ClientForm documentation.  ClientForm is now part of
mechanize, but the documentation hasn't been fully updated to reflect that:
what's here is correct, but not well-integrated with the rest of the
documentation.  This page deals with HTML form handling: parsing HTML forms,
filling them in and returning the completed forms to the server.  See the [main
page](../mechanize) for how to obtain form objects from a `mechanize.Browser`.

For a simple working example, please see `examples/forms/simple.py`.

A more complicated working example, please see `examples/forms/example.py`.

All of the standard control types are supported: `TEXT`, `PASSWORD`, `HIDDEN`,
`TEXTAREA`, `ISINDEX`, `RESET`, `BUTTON` (`INPUT TYPE=BUTTON` and the various
`BUTTON` types), `SUBMIT`, `IMAGE`, `RADIO`, `CHECKBOX`, `SELECT`/`OPTION` and
`FILE` (for file upload).  Both standard form encodings
(`application/x-www-form-urlencoded` and `multipart/form-data`) are supported.

The module is designed for testing and automation of web interfaces, not for
implementing interactive user agents.

***Security note*: Remember that any passwords you store in `HTMLForm`
instances will be saved to disk in the clear if you pickle them (directly or
indirectly).  The simplest solution to this is to avoid pickling `HTMLForm`
objects.  You could also pickle before filling in any password, or just set the
password to `""` before pickling.**

Python 2.0 or above is required.  To run the tests, you need the `unittest`
module (from [PyUnit](http://pyunit.sourceforge.net/)).  `unittest` is a
standard library module with Python 2.1 and above.

For full documentation, see the docstrings.


Parsers
-------

There are two parsers.  See [the FAQ entry on XHTML](./#faq) for details.

[mxTidy](http://www.egenix.com/files/python/mxTidy.html) or
[mu-Tidylib](http://utidylib.berlios.de/) can be useful for dealing with bad
HTML.


Backwards-compatibility mode
----------------------------

mechanize (and ClientForm 0.2) includes three minor backwards-incompatible
interface changes from ClientForm version 0.1.

To make upgrading from ClientForm 0.1 easier, and to allow me to stop
supporting version ClientForm 0.1 sooner, there is support for operating in a
backwards-compatible mode, under which code written for ClientForm 0.1 should
work without modification.  This is done on a per-`HTMLForm` basis via the
`.backwards_compat` attribute, but for convenience the ParseResponse() and
ParseFile() factory functions accept `backwards_compat` arguments.  These
backwards-compatibility features will be removed soon.  The default is to
operate in backwards-compatible mode.  To run with backwards compatible mode
turned ***OFF*** (**strongly recommended**):

~~~~{.python}
from mechanize import ParseResponse, urlopen
forms = ParseResponse(urlopen("http://example.com/"), backwards_compat=False)
# ...
~~~~

The backwards-incompatible changes are:

  * Ambiguous specification of controls or items now results in AmbiguityError.
    If you want the old behaviour, explicitly pass `nr=0` to indicate you want
    the first matching control or item.

  * Item label matching is now done by substring, not by strict string-equality
    (but note leading and trailing space is always stripped). (Control label
    matching is always done by substring.)

  * Handling of disabled list items has changed.  First, note that handling of
    disabled list items in ClientForm 0.1 (and in ClientForm 0.2's
    backwards-compatibility mode!) is buggy: disabled items are successful
    (ie. disabled item names are sent back to the server).  As a result, there
    was no distinction to be made between successful items and selected items.
    In ClientForm 0.2, the bug is fixed, so this is no longer the case, and it
    is important to note that list controls' `.value` attribute contains only
    the *successful* item names; items that are *selected* but not successful
    (because disabled) are not included in `.value`.  Second, disabled list
    items may no longer be deselected: AttributeError is raised in ClientForm
    0.2, whereas deselection was allowed in ClientForm 0.1.  The bug in
    ClientForm 0.1 and in ClientForm 0.2's backwards-compatibility mode will
    not be fixed, to preserve compatibility and to encourage people to upgrade
    to the new ClientForm 0.2 `backwards_compat=False` behaviour.


Credits
-------

Apart from Gisle Aas for allowing the original port from libwww-perl,
particular credit is due to Gary Poster and Benji York, and their employer,
Zope Corporation.  Thanks also to the many people who have contributed bug
reports.


FAQs
----

  * <p class="q">Doesn't the standard Python library module, `cgi`, do this?</p>
    <p>No: the `cgi` module does the server end of the job.  It doesn't know
    how to parse or fill in a form or how to send it back to the server.

  * <p class="q">How do I figure out what control names and values to use?</p>
    <p>`print form` is usually all you need.  In your code, things like the
    `HTMLForm.items` attribute of `HTMLForm` instances can be useful to inspect
    forms at runtime.  Note that it's possible to use item labels instead of
    item names, which can be useful â€” use the `by_label` arguments to the
    various methods, and the `.get_value_by_label()` / `.set_value_by_label()`
    methods on `ListControl`.

  * <p class="q">What do those `'*'` characters mean in the string
    representations of list controls?</p>
    <p>A `*` next to an item means that item is selected.

  * <p class="q">What do those parentheses (round brackets) mean in the string
    representations of list controls?</p>
    <p>Parentheses `(foo)` around an item mean that item is disabled.

  * <p class="q">Why doesn't <some control\> turn up in the data returned by
    `.click*()` when that control has non-`None` value?</p>
    <p>Either the control is disabled, or it is not successful for some other
    reason. 'Successful' (see HTML 4 specification) means that the control will
    cause data to get sent to the server.

  * <p class="q">Why does mechanize not follow the HTML 4.0 / RFC 1866
    standards for `RADIO` and multiple-selection `SELECT` controls?</p>
    <p>Because by default, it follows browser behaviour when setting the
    initially-selected items in list controls that have no items explicitly
    selected in the HTML.  Use the `select_default` argument to `ParseResponse`
    if you want to follow the RFC 1866 rules instead.  Note that browser
    behaviour violates the HTML 4.01 specification in the case of `RADIO`
    controls.

  * <p class="q">Why does `.click()`ing on a button not work for me?</p>

      * Clicking on a `RESET` button doesn't do anything, by design - this is a
        library for web automation, not an interactive browser.  Even in an
        interactive browser, clicking on `RESET` sends nothing to the server,
        so there is little point in having `.click()` do anything special here.

      * Clicking on a `BUTTON TYPE=BUTTON` doesn't do anything either, also by
        design.  This time, the reason is that that `BUTTON` is only in the
        HTML standard so that one can attach callbacks to its events.  The
        callbacks are functions in `SCRIPT` elements (such as Javascript)
        embedded in the HTML, and their execution may result in information
        getting sent back to the server. mechanize, however, knows nothing
        about these callbacks, so it can't do anything useful with a click on a
        `BUTTON` whose type is `BUTTON`.

      * Generally, embedded script may be messing things up in all kinds of
        ways.  See the answer to the next question.

  * <p class="q">Embedded script is messing up my form filling.  What do I
    do?</p>
    <p>See the [General FAQs](../../bits/GeneralFAQ.html) page and the next FAQ
    entry for what to do about this.

  * <p class="q">How do I change `INPUT TYPE=HIDDEN` field values (for example,
to emulate the effect of JavaScript code)?</p>
    <p>As with any control, set the control's `readonly` attribute false.

~~~~{.python}
form.find_control("foo").readonly = False # allow changing .value of control foo
form.set_all_readonly(False) # allow changing the .value of all controls
~~~~

  * <p class="q">I'm having trouble debugging my code.</p>
    <p>See [here](./doc.html#debugging) for few relevant tips.  Also see
    [General FAQs](./GeneralFAQ.html).

  * <p class="q">I have a control containing a list of integers.  How do I
    select the one whose value is nearest to the one I want?</p>

~~~~{.python}
import bisect
def closest_int_value(form, ctrl_name, value):
    values = map(int, [item.name for item in form.find_control(ctrl_name).items])
    return str(values[bisect.bisect(values, value) - 1])

form["distance"] = [closest_int_value(form, "distance", 23)]
~~~~

  * <p class="q">Where can I find out more about the HTML and HTTP standards?</p>

      * W3C [HTML 4.01 Specification](http://www.w3.org/TR/html401/).

      * [RFC 1866](http://www.ietf.org/rfc/rfc1866.txt) - the HTML 2.0
        standard.

      * [RFC 1867](http://www.ietf.org/rfc/rfc1867.txt) - Form-based file
        upload.

      * [RFC 2616](http://www.ietf.org/rfc/rfc2616.txt) - HTTP 1.1
        Specification.

I prefer questions and comments to be sent to the [mailing
list](http://lists.sourceforge.net/lists/listinfo/wwwsearch-general) rather
than direct to me.

<!-- Local Variables: -->
<!-- fill-column:79 -->
<!-- End: -->
